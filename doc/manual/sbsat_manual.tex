%% LyX 1.3 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{article}
\usepackage{ae}
\usepackage{aecompl}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{prettyref}

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
 \newcommand{\lyxaddress}[1]{
   \par {\raggedright #1 
   \vspace{1.4em}
   \noindent\par}
 }
 \newenvironment{lyxcode}
   {\begin{list}{}{
     \setlength{\rightmargin}{\leftmargin}
     \setlength{\listparindent}{0pt}% needed for AMS classes
     \raggedright
     \setlength{\itemsep}{0pt}
     \setlength{\parsep}{0pt}
     \normalfont\ttfamily}%
    \item[]}
   {\end{list}}

\usepackage{babel}
\makeatother
\begin{document}

\title{SBSat Manual}

\maketitle
\begin{center}Written by Michal Kouril, Sean Weaver,... <add your
name here>\\
Covers the versions up to 2.0\end{center}
\newpage

\tableofcontents{}
\newpage


\section{Introduction}

Introduction


\section{Overview}

Overview


\section{Getting SBSat}


\lyxaddress{SBSat is still considered research software. Please email franco@gauss.ececs.uc.edu
for more information how to get it.}


\section{Compiling SBSat}

Considerning you obtained sbsat as tar.gz archive you will need to
unpack it first. Necessary utilities are tar and gzip. They are present
on most platforms. Also most platforms will let you use the following
command to do so:

\begin{lyxcode}
\#~tar~-xvzf~sbsat.tar.gz
\end{lyxcode}
If this command fails please try

\begin{lyxcode}
\#~gzip~-dc~sbsat.tar.gz~|~tar~-xvf~-
\end{lyxcode}
The result should be the directory with the sources. Change the current
directory into newly created one:

\begin{lyxcode}
\#~cd~sbsat
\end{lyxcode}
And run configure and make:

\begin{lyxcode}
\#~./configure

\#~make
\end{lyxcode}
(optional) Using the following command you can run a few included
benchmarks:

\begin{lyxcode}
\#~make~check
\end{lyxcode}
(optional) You may install the executable and associtated files onto
your system using:

\begin{lyxcode}
\#~make~install
\end{lyxcode}
The advantage of this step is that typically the systems have the
path where the executable is installed (/usr/local/bin) as part of
the system PATH variable so you will not need to specify the full
path to start the executable.


\section{Running SBSat}

SBSat executable is called ite and is located in the src directory
within the directory containing the sources for sbsat (sbsat directory).
Unless you installed it to your system in the previous step (make
install) you will need to refer to it with the full path or add this
path into your PATH variable. From now on I will assume that ite was
installed.

The usage of SBSat is:

\begin{lyxcode}
ite~{[}options{]}~{[}inputfile~{[}outputfile{]}{]}
\end{lyxcode}
There are two basic options required by GNU standard:

\begin{lyxcode}
\#~ite~-{}-version
\end{lyxcode}
This displays the current version.

\begin{lyxcode}
\#~ite~-{}-help
\end{lyxcode}
Shows all the command line options.

If ite is started without parameters it expects the input data on
standard input.

The first parameter without dash is the input data file, the second
parameter without is the output file.


\section{Program Options}


\subsection{General options}

SBSat general options are:

\emph{--help, -h} Show all program options 

\emph{--version} Show program version 

\emph{--create-ini} Create ini file 

\emph{--ini <string>} Set the ini file {[}default=\char`\"{}\textasciitilde{}/ite.ini\char`\"{}{]}

\emph{--debug <number>} debugging level (0-none, 9-max) {[}default=2{]}

\emph{--debug-dev <string>} debugging device {[}default=\char`\"{}stderr\char`\"{}{]}

\emph{--params-dump, -D} dump all internal parameters before processing 

\emph{--input-file <string>} input filename {[}default=\char`\"{}-\char`\"{}{]}

\emph{--output-file <string>} output filename {[}default=\char`\"{}-\char`\"{}{]}

\emph{--temp-dir <string>} directory for temporary files {[}default=\char`\"{}\$TEMP\char`\"{}{]}

\emph{--show-result <string>, -R <string>}

Show result (n=no result, r=raw, f=fancy) {[}default=\char`\"{}n\char`\"{}{]}

\emph{--verify-solution <number>} Verify solution {[}default=1{]}

\emph{--expected-result <string>}Report error if the result is not
as specified

Options are SAT, UNSAT, TRIV\_SAT, TRIV\_UNSAT, SOLV\_S

and SOLV\_UNSAT {[}default=\char`\"{}\char`\"{}{]}

\emph{--ctrl-c <number>} Enable/Disable Ctrl-c handler to end preproc/brancher

{[}default=0{]}

\emph{--reports <number>} Reporting style during branching (0 - standard,
1 - crtwin)

{[}default=0{]}


\subsection{BDD table options}

BDD options:

\emph{--num-buckets <number>} Set the number of buckets in power of
2 {[}default=16{]}

\emph{--size-buckets <number>} Set the size of a bucket in power of
2 {[}default=5{]}


\subsection{Input options}

Input options:

\emph{--limit-and-equ <number>}

The minimum \# of literals to flag sp. function and\_eq

u

{[}default=2{]}

\emph{--limit-or-equ <number>} The minimum \# of literals to flag
sp. function or\_equ

{[}default=2{]}

\emph{--limit-or <number>} The minimum \# of literals to flag sp.
function plaino

r

{[}default=8{]}

--limit-xor <number> The minimum \# of literals to flag sp. function
plainx

or

{[}default=5{]}

\emph{--break-xors <number>} Break XORS into linear and non-linear
functions

{[}default=1{]}


\subsection{Output options}

Output options:

\emph{-b} Start regular brancher {[}default{]}

\emph{-w} Start walksat brancher 

\emph{-m} Start WVF brancher 

\emph{-n} Don't start any brancher or conversion 

\emph{-s} Output in SMURF format 

\emph{-c} Output in CNF format 

\emph{-p} Output in tree like format 

\emph{--cnf <string>} Format of CNF output (3sat, qm, noqm)

{[}default=\char`\"{}noqm\char`\"{}{]}

\emph{--tree, -tree} Print tree representation 

\emph{--tree-width <number>, -W <number>} Set tree width {[}default=64{]}


\subsection{Trace format options}

Trace format options:

\emph{--module-dir <string>} directory to find extra modules {[}default=\char`\"{}./Modules\char`\"{}{]}


\subsection{Preprocessing options}

Preprocessing options:

\emph{--preprocess-sequence <string>, -P <string>}

The preprocessing sequence

{[}default=\char`\"{}(ExDc){*}(ExSt){*}(ExPr){*}\char`\"{}{]}

\emph{--All, -All} Enable/Disable All Preprocessing Options (1/0) 

\emph{--Cl <number>, -Cl <number>} Enable/Disable Clustering (1/0)
{[}default=1{]}

\emph{--Co <number>, -Co <number>} Enable/Disable Cofactoring (1/0)
{[}default=1{]}

\emph{--Pr <number>, -Pr <number>} Enable/Disable Pruning (1/0) {[}default=1{]}

\emph{--St <number>, -St <number>} Enable/Disable Strengthening (1/0)
{[}default=1{]}

\emph{--In <number>, -In <number>} Enable/Disable Inferences (1/0)
{[}default=1{]}

\emph{--Ex <number>, -Ex <number>} Enable/Disable Existential Quantification
(1/0) {[}default=1{]}

\emph{--Dc <number>, -Dc <number>} Enable/Disable Dependent Variable
Clustering (1/0)

{[}default=1{]}

\emph{--max-preproc-time <number>} set the time limit in seconds (0=no
limit){[}default=0{]}


\subsection{Brancher options}

Brancher options:

\emph{--reverse-depend, -r} Reverse dependency info on in/dependent
variables 

\emph{--clear-depend, -e} Clear dependency information on variables 

\emph{--heuristic <string>, -H <string>}

Choose heuristic j=Johnson, l=Chaff-like lemma h. i=Interactive {[}default=\char`\"{}j\char`\"{}{]}

\emph{--backjumping <number>} Enable/Disable backjumping (1/0) {[}default=1{]}

\emph{--max-cached-lemmas <number>, -L <number>}

set the maximum \# of lemmas {[}default=5000{]}

\emph{--max-solutions <number>}Set the maximum number of solutions
to search for.{[}default=1{]}

\emph{--sbj <number>} Super backjumping. {[}default=0{]}

\emph{--max-vbles-per-smurf <number>, -S <number>}

set the maximum number variables per smurf {[}default=8{]}

\emph{--backtracks-per-report <number>}set the number of backtracks
per report{[}default=10000{]}

\emph{--max-brancher-time <number>}set the time limit in seconds (0=no
limit){[}default=0{]}

\emph{--max-brancher-cp <number>} set the choice point limit (0=no
limit) {[}default=0{]}

\emph{--brancher-trace-start <number>}

number of backtracks to start the trace (when debug=9){[}default=0{]}

\emph{--compress-smurfs <number>} Share states among smurfs {[}default=1{]}

\emph{--smurfs-share-paths <number>} Share paths among smurfs {[}default=0{]}


\subsection{Johnson heuristic options}

Johnson heuristic options:

\emph{--jheuristic-k <number>, -K <number>} set the value of K {[}default=3.000000{]}

\emph{--jheuristic-k-true <number>} set the value of True state {[}default=0.000000{]}

\emph{--jheuristic-k-inf <number>} set the value of the inference
multiplier

{[}default=1.000000{]}


\section{\label{sec:Input-formats}Input formats}

The ITE Interface is the part of the program that reads in and interprets
the user's input file. This process is as follows: 

1. Format for Input Files


\subsection{BDD (ITE) input format}

The ITE interface is a continuation of a project started by Laura
A. Pugh, August 17 2000 for C123 under the direction of Mark Vanfleet,
Michael Dransfield, and Kelly McGuire. This project is being continued
by Sean Weaver, under the direction of Mark Vanfleet and Dr. John
Franco. The ITE interface is a module which can be used as a front
end on any Satisfiability solver (SAT solver, see page ??). 

The ITE interface provides the user with a unique Binary Decision
Diagram (BDD) interface (See BDDs. page ??). This interface is used
to enter problems into any SAT solver. BDDs allow the user to express
his/her problem data in a way that is natural to it's domain. The
common practice of translating a problem into Conjunctive Normal Form
(CNF) destroys naturally occurring clusters of information that can
be taken advantage of during the search process (See CNF, page ??).
Receiving the input in BDD form also gives traditional SAT solvers
the ability to add and use powerful BDD preprocessing techniques before
search. During search a SAT solver also has the ability to use any
information contained in the BDDs to help it's search heuristic. ITE
can provide a translation to CNF if it is being used in conjunction
with a CNF SAT solver. ITE is currently being used in conjunction
with a SAT solver named SBSat. SBSat is being developed at the University
of Cincinnati by Mark Vanfleet, Michael Dransfield, Dr. John Franco,
Dr. John Schlipf, Sean Weaver, Michal Kouril, and George Vogel. 

There is a header for every input file. Only comments are allowed
to proceed the header. Thus it follows that all equations, defines,
etc., follow directly after the header. 

All equations are entered in prefix format using specific keywords
and variables. There must be some sort of white space between all
keywords and variables. White space is defined to be a blank, a tab,
a carriage return, a comma, or a parentheses. In order to include
comments in the input file, place a semi colon (\char`\"{};\char`\"{})
prior to the comment. This will make the rest of the line a comment
and ITE will not attempt to process it. Comments are not necessary
for the program to operate, but are a convenience for the user. 


\subsubsection{File Header }

In every input file, no equation can precede the header. The header
conforms to the DIMACS standard which is as follows. 

\begin{lyxcode}
p~bdd~\#Vars~\#Equations~
\end{lyxcode}
The letter 'p' at the start of a line denotes the start of the header.
ITE requires that 'bdd' be the next three letters; these denote that
the file is in the BDD format. \#InputVars is a number that and tells
ITE how many input variables are going to appear in this input file.
\#Equations is a number that tells ITE how many equations appear in
this input file. Here is an example of a valid header. 

\begin{lyxcode}
p~bdd~56~97~
\end{lyxcode}
This header tells ITE that the input file is in BDD format with 56
input variables and 97 equations. 


\subsubsection{Keywords }

Keywords are not case sensitive. The current keywords used, with a
brief description of each are as follows: 

\begin{lyxcode}

\end{lyxcode}
\textbf{INITIALBRANCH}

InitialBranch allows the user to specify which variables should be
branched on first during search. InitialBranch is a command that should
only be used when the user is sure he knows more information about
the nature of the input file the attached solver will be able to derive.
This keyword takes any number of positive integer arguments

\begin{lyxcode}
Example:~InitialBranch(~1,~3,~5..18,~4,~24..39)

This~will~mark~variables~1,~3,~5..18~(inclusive),~4,~24..39~(inclusive)~to~be~branched~on~first.

{*}Note~that~this~keyword~is~the~only~keyword~which~requires~parenthesis~around~it's~argument~list{*}~


\end{lyxcode}
\textbf{VAR}

VAR is the base keyword to all equations. It takes one(1) argument,
which must be an integer. VAR creates a BDD for the variable following
it. This BDD will have a true branch and a false branch. \\
The keyword VAR has been made obsolete. It is no longer necessary
to place VAR in front of every variable. It is now assumed that all
integers are variables unless preceded by a '\$'. All integers preceded
by a '\$' refer to equations instead of variables.

\begin{lyxcode}

\end{lyxcode}
\textbf{NOT} 

The NOT function takes one(1) argument and forms a BDD which represents
the negation of that argument. When negating a single variable, a
negative sign (\char`\"{}-\char`\"{}) can be placed directly in front
of the variable as a shortcut (See Shortcuts)

\begin{lyxcode}

\end{lyxcode}
\textbf{ITE} 

The ITE function takes three(3) arguments and forms a BDD which expresses
the If-Then-Else relation of the three(3) arguments. The function
builds a BDD so that if the first parameter evaluates to true, then
the second parameter must be true, else the third parameter must be
true. Every BDD possible can be expressed using the ITE function. 

\begin{lyxcode}
Example:~ITE(~ITE(~3,~\$5,~-5),~4,~7)~

Assume~BDD~\$5~has~been~previously~defined.

{*}Note~that~the~use~of~parenthesis~and~commas~here~is~allowed~but~not~required{*}
\end{lyxcode}
\textbf{AND} 

The AND function takes two(2) arguments and creates a BDD which expresses
the logical AND of the two(2) arguments.

\begin{lyxcode}
Example:~AND~3~4~


\end{lyxcode}
\textbf{AND\#}

AND followed directly by a positive integer is a shortcut designed
to allow the user to send more than two(2) arguments to the AND function.
Any number of arguments is supported here. 

\begin{lyxcode}
Example~1:~AND4(1,~2,~3,~4)

Example~2:~AND5(-1,~

~~~~~~~~~~~~~~~~~~~AND3(2,~3,~\$4),

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~5,~\$6,~7)

Assume~\$4~and~\$6~have~been~previously~defined.

{*}Note~that~the~use~of~white~space~here~is~allowed~but~not~required{*}~


\end{lyxcode}
\textbf{NAND}

The NAND function takes two(2) arguments and creates a BDD which expresses
NOT of the logical AND of the two(2) arguments. 

\begin{lyxcode}

\end{lyxcode}
\textbf{NAND\#}

NAND followed directly by a positive integer is a shortcut designed
to allow the user to send more than two(2) arguments to the NAND function.
Any number of arguments is supported here. 

\begin{lyxcode}

\end{lyxcode}
\textbf{OR}

The OR function takes two(2) arguments and creates a BDD which expresses
the logical OR of the two(2) arguments. 

\begin{lyxcode}

\end{lyxcode}
\textbf{OR\#}

OR followed directly by a positive integer is a shortcut designed
to allow the user to send more than two(2) arguments to the OR function.
Any number of arguments is supported here. 

\begin{lyxcode}

\end{lyxcode}
\textbf{NOR}

The NOR function takes two(2) arguments and creates a BDD which expresses
the NOT of the logical OR of the two(2) arguments. 

\begin{lyxcode}

\end{lyxcode}
\textbf{NOR\#}

NOR followed directly by a positive integer is a shortcut designed
to allow the user to send more than two(2) arguments to the NOR function.
Any number of arguments is supported here. 

\begin{lyxcode}

\end{lyxcode}
\textbf{EQU}

The EQU function takes two(2) arguments and creates a BDD which expresses
that these two(2) arguments are equal to each other. 

\begin{lyxcode}

\end{lyxcode}
\textbf{EQU\#}

EQU followed directly by a positive integer is a shortcut designed
to allow the user to send more than two(2) arguments to the EQU function.
Any number of arguments is supported here. 

\begin{lyxcode}

\end{lyxcode}
\textbf{XOR}

The XOR function takes two(2) arguments and creates a BDD which expresses
that these two(2) arguments are opposite of each other. 

\begin{lyxcode}

\end{lyxcode}
\textbf{XOR\#}

XOR followed directly by a positive integer is a shortcut designed
to allow the user to send more than two(2) arguments to the XOR function.
Any number of arguments is supported here. 

\begin{lyxcode}

\end{lyxcode}
\textbf{IMP}

The IMP function takes two(2) arguments and creates a BDD which expresses
the logical implication of the two(2) arguments.

{*}Take note that IMP does not support multiple arguments as many
of the other keywords do, this is because the implication operator
has strict variable ordering dependence.{*} 

\begin{lyxcode}

\end{lyxcode}
\textbf{NIMP}

The NIMP function takes two(2) arguments and creates a BDD which expresses
the NOT of the logical implication of the two(2) arguments.

{*}Take note that NIMP does not support multiple arguments as many
of the other keywords do, this is because the implication operator
has strict variable ordering dependence.{*} 

\begin{lyxcode}

\end{lyxcode}
\textbf{GCF} 

The GCF function takes two(2) arguments. This function finds all solutions
of both parameters and then creates a BDD which represents the intersection
of these solutions. GCF stands for Generalized Co-Factoring. 

\begin{lyxcode}

\end{lyxcode}
\textbf{STRENGTHEN}

The STRENGTHEN function takes two(2) arguments, e1 and e2. This function
uses the information in e2 to strengthen e1. (See Strengthening, page
??)

\begin{lyxcode}

\end{lyxcode}
\textbf{RESTRICT}

The RESTRICT function takes two(2) arguments, e1 and e2. This function
prunes all branches found in e2 away from e1. (See Restrict, page
??) 

\begin{lyxcode}

\end{lyxcode}
\textbf{EXIST}

The EXIST function takes two(2) arguments, the first argument can
be an equation or a variable (e1), the second argument must be a variable
(v1). This function searches for and finds everyplace in e1 where
v1 occurs. Every time v1 is found it is replaced by the logical OR
of it's true branch and it's false branch. This function effectively
removes v1 from e1. (See Existential Quantification, page ??) 

\begin{lyxcode}

\end{lyxcode}
\textbf{UNIVERSE}

The UNIVERSE function takes two(2) arguments, the first argument can
be an equation or a variable (e1), the second argument must be a variable
(v1). This function searches for and finds everyplace in e1 where
v1 occurs. Every time v1 is found it is replaced by the logical AND
of it's true branch and it's false branch. This function effectively
removes v1 from e1. 

\begin{lyxcode}

\end{lyxcode}
\textbf{PRINT\_TREE} 

The PRINT\_TREE function takes one(1) argument. The argument is printed
to standard out in a nice, easily readable tree form. The argument
is printed from the top down. The branch to the left is the true branch,
the branch to the right is the false branch. 

\begin{lyxcode}
Example:~PRINT\_TREE(~OR3(4,~5,~-6)~)~

Prints~to~standard~output:~

-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~6

~~~~~~~~~~~~~~~~5~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~T

~~~~~~~~T~~~~~~~~~~~~~4~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~T~~~~~~~F

-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-


\end{lyxcode}
\textbf{PPRINT\_TREE}

The PPRINT\_TREE function takes one(1) argument. The argument is printed
to standard out in a different form than PRINT\_TREE. If the true
and false branches are T and F then they are printed on the same line,
otherwise, the true and false branches are indented from the top variable.
The true branch is printed first and is followed by the false branch. 

\begin{lyxcode}
Example:~PPRINT\_TREE(~OR3(4,~5,~-6)~)~

Prints~to~standard~output:

-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-

ite~6

~~~~ite~5

~~~~~~~~T

~~~~~~~~ite~4~T~F

~~~~T

-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-~


\end{lyxcode}
\textbf{MINMAX}

The MINMAX function takes at least 4 arguments. The first argument
is the number of variables that will be in the resulting BDD. The
second argument is the minimum number of variables in the BDD that
need to be set to true to make the BDD evaluate to true. The third
argument is the maximum number of variables in the BDD that can be
set to true for the BDD to evaluate to true. The fourth argument is
the list of variables that make up the BDD.

\begin{lyxcode}
Example:PRINT\_TREE(~MINMAX(4,~1,~3,~13,~12,~11,~10)

Prints~to~standard~output:

-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~13

~~~~~~~~~~~~~~~~12~~~~~~~~~~~~~~~~~~~~~~~~~~~~~12

~~~~~~~~11~~~~~~~~~~~~~~~T~~~~~~~~~~~~~~~T~~~~~~~~~~~~~11

~~~~10~~~~~~~T~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~T~~~~~~10

~~F~~~~T~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~T~~~~F

-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-


\end{lyxcode}
\textbf{ADD\_STATE}

The ADD\_STATE function takes two(2) arguments. The first argument
(e1) must be an equation and the second argument must be a positive
integer (i1). ADD\_STATE creates a new BDD with structure identical
e1 but with each variable incremented by i1. 

\begin{lyxcode}
Example:~ADD\_STATE(~AND(3,~4),~5~)

This~will~create~the~BDD~-~AND(8,~9)~
\end{lyxcode}

\subsubsection{Variable Names }


\subsubsection{Reusing Functions}


\subsubsection{Defines }


\subsubsection{Short Cuts }


\subsubsection{Example Input }

\begin{lyxcode}
{\scriptsize p~bdd~18~13~;~18~vars,~13~functions~}{\scriptsize \par}

{\scriptsize \#define~fun~1~2~3~4~\#~ite~1~and~2~3~or~3~4~;~parms~must~be~consecutive~integers~from~1~}{\scriptsize \par}

{\scriptsize \#define~g~1~2~3~\#~ite(fun(1,~2,~3,~-2),~T,~3)~}{\scriptsize \par}

{\scriptsize InitialBranch~(2,~4..12,~15,~16,~18,~1,~3)~;~These~variables~will~be~branched~on~first~}{\scriptsize \par}

{\scriptsize ite~4~5~6~;~eqn~\$1~}{\scriptsize \par}

{\scriptsize {*}or~\$1~3~;~eqn~\$2,~smurf~1~}{\scriptsize \par}

{\scriptsize {*}or~5~-6~;~eqn~\$3,~smurf~2~}{\scriptsize \par}

{\scriptsize {*}and~\$1~-4~;~eqn~\$4,~smurf~3~}{\scriptsize \par}

{\scriptsize {*}imp~\$1~\$4~;~eqn~\$5,~smurf~4~}{\scriptsize \par}

{\scriptsize \#define~imp~1~2~\#~or3(1,~2,~3);~Notice~the~'imp'~operator~was~overloaded.~}{\scriptsize \par}

{\scriptsize {*}imp(3~4~5)~~~~;~eqn~\$6,~smurf~5~}{\scriptsize \par}

~{\scriptsize ~~~~~~~~~~~~~~;~this~is~a~really~bad~idea,~it~probably~shouldn't~be~allowed}{\scriptsize \par}

{\scriptsize print\_tree~\$5~~;~no~equation~created,~no~smurf~created}{\scriptsize \par}

{\scriptsize pprint\_tree~\$5~;~no~equation~created,~no~smurf~created~}{\scriptsize \par}

{\scriptsize ite(2,~~~~~~~~~~~~~~;~eqn~\$7,~no~smurf~created}{\scriptsize \par}

~{\scriptsize ~~~~~ite(3,~4,~5),~;~plus~comments~are~ignored,~even~in~the~middle~of~a~function~}{\scriptsize \par}

~{\scriptsize ~~~~~ite(4,~5,~F))}{\scriptsize \par}

{\scriptsize {*}fun~4~-5~2~3~;~eqn~\$8,~smurf~6~}{\scriptsize \par}

{\scriptsize {*}fun~g~-5~4~\$6~2~3~4~;~eqn~\$9,~smurf~7}{\scriptsize \par}

{\scriptsize {*}equ(5,~xor3(and(-3,~4),~nand(7,~5),~ite(15,~4,~nor(4,~-7))))~;~eqn~\$10,~smurf~8}{\scriptsize \par}

{\scriptsize {*}add\_state(\$10,~1)~;~eqn~\$11,~smurf~9}{\scriptsize \par}

~{\scriptsize ~~~~~~~~~~~~~~~~~~;~add\_state~creates~a~BDD~which~is~identical~to~the~first}{\scriptsize \par}

~{\scriptsize ~~~~~~~~~~~~~~~~~~;~argument~but~with~all~it's~variables~incremented~by~the}{\scriptsize \par}

~{\scriptsize ~~~~~~~~~~~~~~~~~~;~second~argument.}{\scriptsize \par}

{\scriptsize {*}add\_state(\$10,~2)~;~eqn~\$12,~smurf~10~}{\scriptsize \par}

{\scriptsize {*}add\_state(\$10,~3)~;~eqn~\$13,~smurf~11}{\scriptsize \par}


\end{lyxcode}

\subsection{CNF format}

The CNF format, short for Conjunctive Normal Form, conforms to the
DIMACS CNF standard and contains a few added features.


\subsubsection{File Header}

In every CNF format input file, no equation can precede the header.
Only comments can be written above the header of the file. The header
conforms to the DIMACS standard which is as follows.

\begin{lyxcode}
p~cnf~\#Vars~\#Equations
\end{lyxcode}
The letter 'p' at the start of a new line denotes the start of the
header. The string 'cnf' denotes that the file is in CNF format. \#Vars
is a number denoting how many input variables are going to appear
in this input file. \#Equations is a number denoting how many equations
appear in this input file. Here is an example of a valid header.

\begin{lyxcode}
p~cnf~56~97
\end{lyxcode}
This header tells us that the input file format is CNF and has 56
input variables and 97 equations.


\subsubsection{Equations:}

Each equation in the CNF format is made up of the disjunction of positive
and negative literals. These {}``clauses'' are represented in a
file by a string of positive and negative integers terminating in
a zero.

Example (file small.cnf):

\begin{lyxcode}
p~cnf~6~8~

c~This~is~a~demonstration~of~the~CNF~format~for~the~SBSAT~solver~

1~2~3~0

2~3~4~0

3~4~5~0~

4~5~6~0

-1~-2~-3~0

-2~-3~-4~0

-3~-4~-5~0

-4~-5~-6~0
\end{lyxcode}

\subsubsection{Comments:}

To include comments in a CNF input file, place the single character
'c' prior to the comment. This will make the rest of the line a comment
and every character following the 'c' will be ignored.


\subsection{TRACE format}


\subsection{SMURF format}


\section{Preprocessing}

III. The BDD Tool 

Data is presented to the ITE program via an input file. In this file
BDD variables and BDDs are expressed using all Boolean functions,
e.g., NOT, AND, NAND, OR, NOR, EQU, XOR, IMPLIES, etc. (See page ??
for a full list of commands and a description of each). Every BDD
expressed may be reused when creating other BDD expressions. Input
from this file continues until the specified number of user inputs
has been processed (See page ??). 

The ITE program processes the input given to the program, but the
main tool exercised is the BDD Tool. It completes all of the manipulations
and calculations necessary to build the BDD structure. The BDD Tool
comes standard with many powerful BDD functions (See page ??). These
functions give the user total control over their problem data. 


\subsection{Existential Quantification}


\subsection{Restrict}


\subsection{Strengthening}


\subsection{Dependent clustering}


\subsection{Cofactoring}


\section{Solver}

The execution is handed to the solver after preprocessing is done.
There are four different options controlled by the command line (ini
file):

\begin{itemize}
\item SMURF brancher (default or when -b specified on the command line)
\item BDD WalkSat (-w)
\item WVF brancher (original pre-sbsat brancher)
\item or it will start conversion of the internal problem representation
into one of the specified formats.
\end{itemize}

\subsection{SMURF Brancher}

SMURF Brancher is given the problem as a collection of BDDs. Some
of the BDDs are marked as special functions (AND, OR, AND=, XOR, ...).
It converts non-special function BDDs and BDDs where the special function
is not recognized (IMP, ...) into SMURF state machines. Special functions
are handled using non-SMURF data structures in order to save memory
space. 

After conversion into SMURFs the process of solving the problem starts.
There are .. major parts:

\begin{itemize}
\item heuristic - after processing all inferences without contradiction
the new literal is chosen by looking at the heuristic values. Please
see \prettyref{sec:Solver-heuristics}
\item inference queue - every new inference is first put into the inference
queue but the value of the inference is set as soon as it is found.
The consequences of the inferences are processed in FIFO style (updating
the SMURFs, special functions and lemmas).
\item smurf update
\item special function update
\item lemma update
\item lemmas
\item backtracking
\end{itemize}

\subsection{BDDWalkSat}

(Sean!) Woohoo!


\subsection{WVF Brancher}


\section{\label{sec:Solver-heuristics}Solver heuristics}


\subsection{Johnson heuristic}


\subsection{Chaff like lemma heuristic}


\section{Output formats}

For format description please see \prettyref{sec:Input-formats}.


\section{Examples on how to use SBSat}


\section{Reporting problems}


\lyxaddress{Report bugs to <mkouril@ececs.uc.edu> or <franco@gauss.ececs.uc.edu>.}
\end{document}
