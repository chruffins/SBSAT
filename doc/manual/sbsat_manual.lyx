#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass article
\language english
\inputencoding auto
\fontscheme ae
\graphics default
\paperfontsize default
\spacing single 
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title

SBSat Manual
\layout Standard
\pagebreak_bottom \align center 
Written by Michal Kouril, Sean Weaver,...
 <add your name here>
\newline 
Covers the versions up to 2.0
\layout Standard
\pagebreak_bottom 

\begin_inset LatexCommand \tableofcontents{}

\end_inset 


\layout Section

Introduction
\layout Standard

Introduction
\layout Section

Overview
\layout Standard

Overview
\layout Section

Getting SBSat
\layout Address

SBSat is still considered research software.
 Please email franco@gauss.ececs.uc.edu for more information how to get it.
\layout Section

Compiling SBSat
\layout Standard

Considerning you obtained sbsat as tar.gz archive you will need to unpack
 it first.
 Necessary utilities are tar and gzip.
 They are present on most platforms.
 Also most platforms will let you use the following command to do so:
\layout LyX-Code

# tar -xvzf sbsat.tar.gz
\layout Standard

If this command fails please try
\layout LyX-Code

# gzip -dc sbsat.tar.gz | tar -xvf -
\layout Standard

The result should be the directory with the sources.
 Change the current directory into newly created one:
\layout LyX-Code

# cd sbsat
\layout Standard

And run configure and make:
\layout LyX-Code

# ./configure
\layout LyX-Code

# make
\layout Standard

(optional) Using the following command you can run a few included benchmarks:
\layout LyX-Code

# make check
\layout Standard

(optional) You may install the executable and associtated files onto your
 system using:
\layout LyX-Code

# make install
\layout Standard

The advantage of this step is that typically the systems have the path where
 the executable is installed (/usr/local/bin) as part of the system PATH
 variable so you will not need to specify the full path to start the executable.
\layout Section

Running SBSat
\layout Standard

SBSat executable is called ite and is located in the src directory within
 the directory containing the sources for sbsat (sbsat directory).
 Unless you installed it to your system in the previous step (make install)
 you will need to refer to it with the full path or add this path into your
 PATH variable.
 From now on I will assume that ite was installed.
\layout Standard

The usage of SBSat is:
\layout LyX-Code

ite [options] [inputfile [outputfile]]
\layout Standard

There are two basic options required by GNU standard:
\layout LyX-Code

# ite --version
\layout Standard

This displays the current version.
\layout LyX-Code

# ite --help
\layout Standard

Shows all the command line options.
\layout Standard

If ite is started without parameters it expects the input data on standard
 input.
\layout Standard

The first parameter without dash is the input data file, the second parameter
 without is the output file.
\layout Section

Program Options
\layout Subsection

General options
\layout Standard

SBSat general options are:
\layout Standard


\emph on 
--help, -h
\emph default 
 Show all program options 
\layout Standard


\emph on 
--version
\emph default 
 Show program version 
\layout Standard


\emph on 
--create-ini
\emph default 
 Create ini file 
\layout Standard


\emph on 
--ini <string>
\emph default 
 Set the ini file [default="~/ite.ini"]
\layout Standard


\emph on 
--debug <number>
\emph default 
 debugging level (0-none, 9-max) [default=2]
\layout Standard


\emph on 
--debug-dev <string>
\emph default 
 debugging device [default="stderr"]
\layout Standard


\emph on 
--params-dump, -D
\emph default 
 dump all internal parameters before processing 
\layout Standard


\emph on 
--input-file <string>
\emph default 
 input filename [default="-"]
\layout Standard


\emph on 
--output-file <string>
\emph default 
 output filename [default="-"]
\layout Standard


\emph on 
--temp-dir <string>
\emph default 
 directory for temporary files [default="$TEMP"]
\layout Standard


\emph on 
--show-result <string>, -R <string>
\layout Standard

Show result (n=no result, r=raw, f=fancy) [default="n"]
\layout Standard


\emph on 
--verify-solution <number>
\emph default 
 Verify solution [default=1]
\layout Standard


\emph on 
--expected-result <string>
\emph default 
Report error if the result is not as specified
\layout Standard

Options are SAT, UNSAT, TRIV_SAT, TRIV_UNSAT, SOLV_S
\layout Standard

and SOLV_UNSAT [default=""]
\layout Standard


\emph on 
--ctrl-c <number> 
\emph default 
Enable/Disable Ctrl-c handler to end preproc/brancher
\layout Standard

[default=0]
\layout Standard


\emph on 
--reports <number>
\emph default 
 Reporting style during branching (0 - standard, 1 - crtwin)
\layout Standard

[default=0]
\layout Subsection

BDD table options
\layout Standard

BDD options:
\layout Standard


\emph on 
--num-buckets <number>
\emph default 
 Set the number of buckets in power of 2 [default=16]
\layout Standard


\emph on 
--size-buckets <number>
\emph default 
 Set the size of a bucket in power of 2 [default=5]
\layout Subsection

Input options
\layout Standard

Input options:
\layout Standard


\emph on 
--limit-and-equ <number>
\layout Standard

The minimum # of literals to flag sp.
 function and_eq
\layout Standard

u
\layout Standard

[default=2]
\layout Standard


\emph on 
--limit-or-equ <number> 
\emph default 
The minimum # of literals to flag sp.
 function or_equ
\layout Standard

[default=2]
\layout Standard


\emph on 
--limit-or <number> 
\emph default 
The minimum # of literals to flag sp.
 function plaino
\layout Standard

r
\layout Standard

[default=8]
\layout Standard

--limit-xor <number> The minimum # of literals to flag sp.
 function plainx
\layout Standard

or
\layout Standard

[default=5]
\layout Standard


\emph on 
--break-xors <number>
\emph default 
 Break XORS into linear and non-linear functions
\layout Standard

[default=1]
\layout Subsection

Output options
\layout Standard

Output options:
\layout Standard


\emph on 
-b
\emph default 
 Start regular brancher [default]
\layout Standard


\emph on 
-w
\emph default 
 Start walksat brancher 
\layout Standard


\emph on 
-m
\emph default 
 Start WVF brancher 
\layout Standard


\emph on 
-n
\emph default 
 Don't start any brancher or conversion 
\layout Standard


\emph on 
-s
\emph default 
 Output in SMURF format 
\layout Standard


\emph on 
-c
\emph default 
 Output in CNF format 
\layout Standard


\emph on 
-p
\emph default 
 Output in tree like format 
\layout Standard


\emph on 
--cnf <string>
\emph default 
 Format of CNF output (3sat, qm, noqm)
\layout Standard

[default="noqm"]
\layout Standard


\emph on 
--tree, -tree
\emph default 
 Print tree representation 
\layout Standard


\emph on 
--tree-width <number>, -W <number>
\emph default 
 Set tree width [default=64]
\layout Subsection

Trace format options
\layout Standard

Trace format options:
\layout Standard


\emph on 
--module-dir <string>
\emph default 
 directory to find extra modules [default="./Modules"]
\layout Subsection

Preprocessing options
\layout Standard

Preprocessing options:
\layout Standard


\emph on 
--preprocess-sequence <string>, -P <string>
\layout Standard

The preprocessing sequence
\layout Standard

[default="(ExDc)*(ExSt)*(ExPr)*"]
\layout Standard


\emph on 
--All, -All
\emph default 
 Enable/Disable All Preprocessing Options (1/0) 
\layout Standard


\emph on 
--Cl <number>, -Cl <number>
\emph default 
 Enable/Disable Clustering (1/0) [default=1]
\layout Standard


\emph on 
--Co <number>, -Co <number>
\emph default 
 Enable/Disable Cofactoring (1/0) [default=1]
\layout Standard


\emph on 
--Pr <number>, -Pr <number>
\emph default 
 Enable/Disable Pruning (1/0) [default=1]
\layout Standard


\emph on 
--St <number>, -St <number>
\emph default 
 Enable/Disable Strengthening (1/0) [default=1]
\layout Standard


\emph on 
--In <number>, -In <number>
\emph default 
 Enable/Disable Inferences (1/0) [default=1]
\layout Standard


\emph on 
--Ex <number>, -Ex <number>
\emph default 
 Enable/Disable Existential Quantification (1/0) [default=1]
\layout Standard


\emph on 
--Dc <number>, -Dc <number>
\emph default 
 Enable/Disable Dependent Variable Clustering (1/0)
\layout Standard

[default=1]
\layout Standard


\emph on 
--max-preproc-time <number>
\emph default 
 set the time limit in seconds (0=no limit)[default=0]
\layout Subsection

Brancher options
\layout Standard

Brancher options:
\layout Standard


\emph on 
--reverse-depend, -r
\emph default 
 Reverse dependency info on in/dependent variables 
\layout Standard


\emph on 
--clear-depend, -e
\emph default 
 Clear dependency information on variables 
\layout Standard


\emph on 
--heuristic <string>, -H <string>
\layout Standard

Choose heuristic j=Johnson, l=Chaff-like lemma h.
 i=Interactive [default="j"]
\layout Standard


\emph on 
--backjumping <number>
\emph default 
 Enable/Disable backjumping (1/0) [default=1]
\layout Standard


\emph on 
--max-cached-lemmas <number>, -L <number>
\layout Standard

set the maximum # of lemmas [default=5000]
\layout Standard


\emph on 
--max-solutions <number>
\emph default 
Set the maximum number of solutions to search for.[default=1]
\layout Standard


\emph on 
--sbj <number>
\emph default 
 Super backjumping.
 [default=0]
\layout Standard


\emph on 
--max-vbles-per-smurf <number>, -S <number>
\layout Standard

set the maximum number variables per smurf [default=8]
\layout Standard


\emph on 
--backtracks-per-report <number>
\emph default 
set the number of backtracks per report[default=10000]
\layout Standard


\emph on 
--max-brancher-time <number>
\emph default 
set the time limit in seconds (0=no limit)[default=0]
\layout Standard


\emph on 
--max-brancher-cp <number>
\emph default 
 set the choice point limit (0=no limit) [default=0]
\layout Standard


\emph on 
--brancher-trace-start <number>
\layout Standard

number of backtracks to start the trace (when debug=9)[default=0]
\layout Standard


\emph on 
--compress-smurfs <number>
\emph default 
 Share states among smurfs [default=1]
\layout Standard


\emph on 
--smurfs-share-paths <number>
\emph default 
 Share paths among smurfs [default=0]
\layout Subsection

Johnson heuristic options
\layout Standard

Johnson heuristic options:
\layout Standard


\emph on 
--jheuristic-k <number>, -K <number>
\emph default 
 set the value of K [default=3.000000]
\layout Standard


\emph on 
--jheuristic-k-true <number>
\emph default 
 set the value of True state [default=0.000000]
\layout Standard


\emph on 
--jheuristic-k-inf <number>
\emph default 
 set the value of the inference multiplier
\layout Standard

[default=1.000000]
\layout Section


\begin_inset LatexCommand \label{sec:Input-formats}

\end_inset 

Input formats
\layout Standard

The ITE Interface is the part of the program that reads in and interprets
 the user's input file.
 This process is as follows: 
\layout Standard

1.
 Format for Input Files
\layout Subsection

BDD (ITE) input format
\layout Standard

The ITE interface is a continuation of a project started by Laura A.
 Pugh, August 17 2000 for C123 under the direction of Mark Vanfleet, Michael
 Dransfield, and Kelly McGuire.
 This project is being continued by Sean Weaver, under the direction of
 Mark Vanfleet and Dr.
 John Franco.
 The ITE interface is a module which can be used as a front end on any Satisfiab
ility solver (SAT solver, see page ??).
 
\layout Standard

The ITE interface provides the user with a unique Binary Decision Diagram
 (BDD) interface (See BDDs.
 page ??).
 This interface is used to enter problems into any SAT solver.
 BDDs allow the user to express his/her problem data in a way that is natural
 to it's domain.
 The common practice of translating a problem into Conjunctive Normal Form
 (CNF) destroys naturally occurring clusters of information that can be
 taken advantage of during the search process (See CNF, page ??).
 Receiving the input in BDD form also gives traditional SAT solvers the
 ability to add and use powerful BDD preprocessing techniques before search.
 During search a SAT solver also has the ability to use any information
 contained in the BDDs to help it's search heuristic.
 ITE can provide a translation to CNF if it is being used in conjunction
 with a CNF SAT solver.
 ITE is currently being used in conjunction with a SAT solver named SBSat.
 SBSat is being developed at the University of Cincinnati by Mark Vanfleet,
 Michael Dransfield, Dr.
 John Franco, Dr.
 John Schlipf, Sean Weaver, Michal Kouril, and George Vogel.
 
\layout Standard

There is a header for every input file.
 Only comments are allowed to proceed the header.
 Thus it follows that all equations, defines, etc., follow directly after
 the header.
 
\layout Standard

All equations are entered in prefix format using specific keywords and variables.
 There must be some sort of white space between all keywords and variables.
 White space is defined to be a blank, a tab, a carriage return, a comma,
 or a parentheses.
 In order to include comments in the input file, place a semi colon (";")
 prior to the comment.
 This will make the rest of the line a comment and ITE will not attempt
 to process it.
 Comments are not necessary for the program to operate, but are a convenience
 for the user.
 
\layout Subsubsection

File Header 
\layout Standard

In every input file, no equation can precede the header.
 The header conforms to the DIMACS standard which is as follows.
 
\layout LyX-Code

p bdd #Vars #Equations 
\layout Standard

The letter 'p' at the start of a line denotes the start of the header.
 ITE requires that 'bdd' be the next three letters; these denote that the
 file is in the BDD format.
 #InputVars is a number that and tells ITE how many input variables are
 going to appear in this input file.
 #Equations is a number that tells ITE how many equations appear in this
 input file.
 Here is an example of a valid header.
 
\layout LyX-Code

p bdd 56 97 
\layout Standard

This header tells ITE that the input file is in BDD format with 56 input
 variables and 97 equations.
 
\layout Subsubsection

Keywords 
\layout Standard

Keywords are not case sensitive.
 The current keywords used, with a brief description of each are as follows:
 
\layout LyX-Code

\layout Standard


\series bold 
INITIALBRANCH
\layout Standard

InitialBranch allows the user to specify which variables should be branched
 on first during search.
 InitialBranch is a command that should only be used when the user is sure
 he knows more information about the nature of the input file the attached
 solver will be able to derive.
 This keyword takes any number of positive integer arguments
\layout LyX-Code

Example: InitialBranch( 1, 3, 5..18, 4, 24..39)
\layout LyX-Code

This will mark variables 1, 3, 5..18 (inclusive), 4, 24..39 (inclusive) to be
 branched on first.
\layout LyX-Code

*Note that this keyword is the only keyword which requires parenthesis around
 it's argument list* 
\layout LyX-Code

\layout Standard


\series bold 
VAR
\layout Standard

VAR is the base keyword to all equations.
 It takes one(1) argument, which must be an integer.
 VAR creates a BDD for the variable following it.
 This BDD will have a true branch and a false branch.
 
\newline 
The keyword VAR has been made obsolete.
 It is no longer necessary to place VAR in front of every variable.
 It is now assumed that all integers are variables unless preceded by a
 '$'.
 All integers preceded by a '$' refer to equations instead of variables.
\layout LyX-Code

\layout Standard


\series bold 
NOT
\series default 
 
\layout Standard

The NOT function takes one(1) argument and forms a BDD which represents
 the negation of that argument.
 When negating a single variable, a negative sign ("-") can be placed directly
 in front of the variable as a shortcut (See Shortcuts)
\layout LyX-Code

\layout Standard


\series bold 
ITE
\series default 
 
\layout Standard

The ITE function takes three(3) arguments and forms a BDD which expresses
 the If-Then-Else relation of the three(3) arguments.
 The function builds a BDD so that if the first parameter evaluates to true,
 then the second parameter must be true, else the third parameter must be
 true.
 Every BDD possible can be expressed using the ITE function.
 
\layout LyX-Code

Example: ITE( ITE( 3, $5, -5), 4, 7) 
\layout LyX-Code

Assume BDD $5 has been previously defined.
\layout LyX-Code

*Note that the use of parenthesis and commas here is allowed but not required*
\layout Standard


\series bold 
AND
\series default 
 
\layout Standard

The AND function takes two(2) arguments and creates a BDD which expresses
 the logical AND of the two(2) arguments.
\layout LyX-Code

Example: AND 3 4 
\layout LyX-Code

\layout Standard


\series bold 
AND#
\layout Standard

AND followed directly by a positive integer is a shortcut designed to allow
 the user to send more than two(2) arguments to the AND function.
 Any number of arguments is supported here.
 
\layout LyX-Code

Example 1: AND4(1, 2, 3, 4)
\layout LyX-Code

Example 2: AND5(-1, 
\layout LyX-Code

                   AND3(2, 3, $4),
\layout LyX-Code

                                  5, $6, 7)
\layout LyX-Code

Assume $4 and $6 have been previously defined.
\layout LyX-Code

*Note that the use of white space here is allowed but not required* 
\layout LyX-Code

\layout Standard


\series bold 
NAND
\layout Standard

The NAND function takes two(2) arguments and creates a BDD which expresses
 NOT of the logical AND of the two(2) arguments.
 
\layout LyX-Code

\layout Standard


\series bold 
NAND#
\layout Standard

NAND followed directly by a positive integer is a shortcut designed to allow
 the user to send more than two(2) arguments to the NAND function.
 Any number of arguments is supported here.
 
\layout LyX-Code

\layout Standard


\series bold 
OR
\layout Standard

The OR function takes two(2) arguments and creates a BDD which expresses
 the logical OR of the two(2) arguments.
 
\layout LyX-Code

\layout Standard


\series bold 
OR#
\layout Standard

OR followed directly by a positive integer is a shortcut designed to allow
 the user to send more than two(2) arguments to the OR function.
 Any number of arguments is supported here.
 
\layout LyX-Code

\layout Standard


\series bold 
NOR
\layout Standard

The NOR function takes two(2) arguments and creates a BDD which expresses
 the NOT of the logical OR of the two(2) arguments.
 
\layout LyX-Code

\layout Standard


\series bold 
NOR#
\layout Standard

NOR followed directly by a positive integer is a shortcut designed to allow
 the user to send more than two(2) arguments to the NOR function.
 Any number of arguments is supported here.
 
\layout LyX-Code

\layout Standard


\series bold 
EQU
\layout Standard

The EQU function takes two(2) arguments and creates a BDD which expresses
 that these two(2) arguments are equal to each other.
 
\layout LyX-Code

\layout Standard


\series bold 
EQU#
\layout Standard

EQU followed directly by a positive integer is a shortcut designed to allow
 the user to send more than two(2) arguments to the EQU function.
 Any number of arguments is supported here.
 
\layout LyX-Code

\layout Standard


\series bold 
XOR
\layout Standard

The XOR function takes two(2) arguments and creates a BDD which expresses
 that these two(2) arguments are opposite of each other.
 
\layout LyX-Code

\layout Standard


\series bold 
XOR#
\layout Standard

XOR followed directly by a positive integer is a shortcut designed to allow
 the user to send more than two(2) arguments to the XOR function.
 Any number of arguments is supported here.
 
\layout LyX-Code

\layout Standard


\series bold 
IMP
\layout Standard

The IMP function takes two(2) arguments and creates a BDD which expresses
 the logical implication of the two(2) arguments.
\layout Standard

*Take note that IMP does not support multiple arguments as many of the other
 keywords do, this is because the implication operator has strict variable
 ordering dependence.* 
\layout LyX-Code

\layout Standard


\series bold 
NIMP
\layout Standard

The NIMP function takes two(2) arguments and creates a BDD which expresses
 the NOT of the logical implication of the two(2) arguments.
\layout Standard

*Take note that NIMP does not support multiple arguments as many of the
 other keywords do, this is because the implication operator has strict
 variable ordering dependence.* 
\layout LyX-Code

\layout Standard


\series bold 
GCF
\series default 
 
\layout Standard

The GCF function takes two(2) arguments.
 This function finds all solutions of both parameters and then creates a
 BDD which represents the intersection of these solutions.
 GCF stands for Generalized Co-Factoring.
 
\layout LyX-Code

\layout Standard


\series bold 
STRENGTHEN
\layout Standard

The STRENGTHEN function takes two(2) arguments, e1 and e2.
 This function uses the information in e2 to strengthen e1.
 (See Strengthening, page ??)
\layout LyX-Code

\layout Standard


\series bold 
PRUNE
\series default 
 
\layout Standard

The PRUNE function takes two(2) arguments, e1 and e2.
 This function prunes all branches found in e2 away from e1.
 (See Branch Pruning, page ??) 
\layout LyX-Code

\layout Standard


\series bold 
EXIST
\layout Standard

The EXIST function takes two(2) arguments, the first argument can be an
 equation or a variable (e1), the second argument must be a variable (v1).
 This function searches for and finds everyplace in e1 where v1 occurs.
 Every time v1 is found it is replaced by the logical OR of it's true branch
 and it's false branch.
 This function effectively removes v1 from e1.
 (See Existential Quantification, page ??) 
\layout LyX-Code

\layout Standard


\series bold 
UNIVERSE
\layout Standard

The UNIVERSE function takes two(2) arguments, the first argument can be
 an equation or a variable (e1), the second argument must be a variable
 (v1).
 This function searches for and finds everyplace in e1 where v1 occurs.
 Every time v1 is found it is replaced by the logical AND of it's true branch
 and it's false branch.
 This function effectively removes v1 from e1.
 
\layout LyX-Code

\layout Standard


\series bold 
PRINT_TREE
\series default 
 
\layout Standard

The PRINT_TREE function takes one(1) argument.
 The argument is printed to standard out in a nice, easily readable tree
 form.
 The argument is printed from the top down.
 The branch to the left is the true branch, the branch to the right is the
 false branch.
 
\layout LyX-Code

Example: PRINT_TREE( OR3(4, 5, -6) ) 
\layout LyX-Code

Prints to standard output:
\layout LyX-Code

--------------------------------------------------- 
\layout LyX-Code

                         4 
\layout LyX-Code

               T                   5 
\layout LyX-Code

                              T         6 
\layout LyX-Code

                                     F     T 
\layout LyX-Code

--------------------------------------------------- 
\layout LyX-Code

\layout Standard


\series bold 
PPRINT_TREE
\layout Standard

The PPRINT_TREE function takes one(1) argument.
 The argument is printed to standard out in a different form than PRINT_TREE.
 If the true and false branches are T and F then they are printed on the
 same line, otherwise, the true and false branches are indented from the
 top variable.
 The true branch is printed first and is followed by the false branch.
 
\layout LyX-Code

Example: PPRINT_TREE( OR3(4, 5, -6) ) 
\layout LyX-Code

Prints to standard output:
\layout LyX-Code

-------------------------------------------------------
\layout LyX-Code

ite 4
\layout LyX-Code

    T
\layout LyX-Code

    ite 5
\layout LyX-Code

        T
\layout LyX-Code

        ite 6 F T
\layout LyX-Code

------------------------------------------------------- 
\layout LyX-Code

\layout Standard


\series bold 
ADD_STATE
\layout Standard

The ADD_STATE function takes two(2) arguments.
 The first argument (e1) must be an equation and the second argument must
 be a positive integer (i1).
 ADD_STATE creates a new BDD with structure identical e1 but with each variable
 incremented by i1.
 
\layout LyX-Code

Example: ADD_STATE( AND(3, 4), 5 )
\layout LyX-Code

This will create the BDD - AND(8, 9) 
\layout Subsubsection

Variable Names 
\layout Subsubsection

Reusing Functions
\layout Subsubsection

Defines 
\layout Subsubsection

Short Cuts 
\layout Subsubsection

Example Input 
\layout LyX-Code


\size scriptsize 
p bdd 18 13 ; 18 vars, 13 functions 
\layout LyX-Code


\size scriptsize 
#define fun 1 2 3 4 # ite 1 and 2 3 or 3 4 ; parms must be consecutive integers
 from 1 
\layout LyX-Code


\size scriptsize 
#define g 1 2 3 # ite(fun(1, 2, 3, -2), T, 3) 
\layout LyX-Code


\size scriptsize 
InitialBranch (2, 4..12, 15, 16, 18, 1, 3) ; These variables will be branched
 on first 
\layout LyX-Code


\size scriptsize 
ite 4 5 6 ; eqn $1 
\layout LyX-Code


\size scriptsize 
*or $1 3 ; eqn $2, smurf 1 
\layout LyX-Code


\size scriptsize 
*or 5 -6 ; eqn $3, smurf 2 
\layout LyX-Code


\size scriptsize 
*and $1 -4 ; eqn $4, smurf 3 
\layout LyX-Code


\size scriptsize 
*imp $1 $4 ; eqn $5, smurf 4 
\layout LyX-Code


\size scriptsize 
#define imp 1 2 # or3(1, 2, 3); Notice the 'imp' operator was overloaded
 to be the OR of 3 variables.
 
\layout LyX-Code


\size scriptsize 
*imp(3 4 5)    ; eqn $6, smurf 5 
\layout LyX-Code


\size scriptsize 
               ; this is a really bad idea, it probably shouldn't be allowed
\layout LyX-Code


\size scriptsize 
print_tree $5  ; no equation created, no smurf created
\layout LyX-Code


\size scriptsize 
pprint_tree $5 ; no equation created, no smurf created 
\layout LyX-Code


\size scriptsize 
ite(2,              ; eqn $7, no smurf created
\layout LyX-Code


\size scriptsize 
      ite(3, 4, 5), ; plus comments are ignored, even in the middle of a
 function 
\layout LyX-Code


\size scriptsize 
      ite(4, 5, F))
\layout LyX-Code


\size scriptsize 
*fun 4 -5 2 3 ; eqn $8, smurf 6 
\layout LyX-Code


\size scriptsize 
*fun g -5 4 $6 2 3 4 ; eqn $9, smurf 7
\layout LyX-Code


\size scriptsize 
*equ(xor3(2, and(-3, 4), nand(7, 5), ite(15, or(4, -7), nor(4, -7)))) ;
 eqn $10, smurf 8
\layout LyX-Code


\size scriptsize 
*add_state($10, 1) ; eqn $11, smurf 9
\layout LyX-Code


\size scriptsize 
                   ; add_state creates a BDD which is identical to the first
 argument but 
\layout LyX-Code


\size scriptsize 
                   ; with all it's variables incremented by the second argument.
\layout LyX-Code


\size scriptsize 
*add_state($10, 2) ; eqn $12, smurf 10 
\layout LyX-Code


\size scriptsize 
*add_state($10, 3) ; eqn $13, smurf 11
\layout LyX-Code

\layout Subsection

CNF format
\layout Subsection

TRACE format
\layout Subsection

SMURF format
\layout Section

Preprocessing
\layout Standard

III.
 The BDD Tool 
\layout Standard

Data is presented the ITE program via an input file.
 In this file BDD variables and BDDs are expressed using all Boolean functions,
 e.g., NOT, AND, NAND, OR, NOR, EQU, XOR, IMPLIES, etc.
 (See page ?? for a full list of commands and a description of each).
 Every BDD expressed may be reused when creating other BDD expressions.
 Input from this file continues until the specified number of user inputs
 has been processed (See page ??).
 
\layout Standard

The ITE program processes the input given to the program, but the main tool
 exercised is the BDD Tool.
 It completes all of the manipulations and calculations necessary to build
 the BDD structure.
 The BDD Tool comes standard with many powerful BDD functions (See page
 ??).
 These functions give the user total control over their problem data.
 
\layout Subsection

Existential Quantification
\layout Subsection

Branch Pruning
\layout Subsection

Strengthening
\layout Subsection

Dependent clustering
\layout Subsection

Cofactoring
\layout Section

Solver
\layout Standard

The execution is handed to the solver after preprocessing is done.
 There are four different options controlled by the command line (ini file):
\layout Itemize

SMURF brancher (default or when -b specified on the command line)
\layout Itemize

BDD WalkSat (-w)
\layout Itemize

WVF brancher (original pre-sbsat brancher)
\layout Itemize

or it will start conversion of the internal problem representation into
 one of the specified formats.
\layout Subsection

SMURF Brancher
\layout Standard

SMURF Brancher is given the problem as a collection of BDDs.
 Some of the BDDs are marked as special functions (AND, OR, AND=, XOR, ...).
 It converts non-special function BDDs and BDDs where the special function
 is not recognized (IMP, ...) into SMURF state machines.
 Special functions are handled using non-SMURF data structures in order
 to save memory space.
 
\layout Standard

After conversion into SMURFs the process of solving the problem starts.
 There are ..
 major parts:
\layout Itemize

heuristic - after processing all inferences without contradiction the new
 literal is chosen by looking at the heuristic values.
 Please see 
\begin_inset LatexCommand \prettyref{sec:Solver-heuristics}

\end_inset 


\layout Itemize

inference queue - every new inference is first put into the inference queue
 but the value of the inference is set as soon as it is found.
 The consequences of the inferences are processed in FIFO style (updating
 the SMURFs, special functions and lemmas).
\layout Itemize

smurf update
\layout Itemize

special function update
\layout Itemize

lemma update
\layout Itemize

lemmas
\layout Itemize

backtracking
\layout Subsection

BDDWalkSat
\layout Standard

(Sean!) Woohoo!
\layout Subsection

WVF Brancher
\layout Section


\begin_inset LatexCommand \label{sec:Solver-heuristics}

\end_inset 

Solver heuristics
\layout Subsection

Johnson heuristic
\layout Subsection

Chaff like lemma heuristic
\layout Section

Output formats
\layout Standard

For format description please see 
\begin_inset LatexCommand \prettyref{sec:Input-formats}

\end_inset 

.
\layout Section

Examples on how to use SBSat
\layout Section

Reporting problems
\layout Address

Report bugs to <mkouril@ececs.uc.edu> or <franco@gauss.ececs.uc.edu>.
\the_end
