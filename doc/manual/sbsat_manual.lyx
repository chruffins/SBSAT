#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass article
\language english
\inputencoding auto
\fontscheme ae
\graphics default
\paperfontsize default
\spacing single 
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title

SBSat Manual
\layout Standard
\pagebreak_bottom \align center 
Written by Michal Kouril, Sean Weaver,...
 <add your name here>
\newline 
Covers the versions up to 2.0
\layout Standard
\pagebreak_bottom 

\begin_inset LatexCommand \tableofcontents{}

\end_inset 


\layout Section

Introduction
\layout Standard

The ITE interface is a continuation of a project started by Laura A.
 Pugh, August 17 2000 for C123 under the direction of Mark Vanfleet, Michael
 Dransfield, and Kelly McGuire.
 This project is being continued by Sean Weaver, under the direction of
 Mark Vanfleet and Dr.
 John Franco.
 The ITE interface is a module which can be used as a front end on any Satisfiab
ility solver (SAT solver, see page ??).
 
\layout Section

Overview
\layout Standard

The ITE interface provides the user with a unique Binary Decision Diagram
 (BDD) interface (See BDDs.
 page ??).
 This interface is used to enter problems into any SAT solver.
 BDDs allow the user to express his/her problem data in a way that is natural
 to it's domain.
 The common practice of translating a problem into Conjunctive Normal Form
 (CNF) destroys naturally occurring clusters of information that can be
 taken advantage of during the search process (See CNF, page ??).
 Receiving the input in BDD form also gives traditional SAT solvers the
 ability to add and use powerful BDD preprocessing techniques before search.
 During search a SAT solver also has the ability to use any information
 contained in the BDDs to help it's search heuristic.
 ITE can provide a translation to CNF if it is being used in conjunction
 with a CNF SAT solver.
 ITE is currently being used in conjunction with a SAT solver named SBSAT.
 SBSAT is being developed at the University of Cincinnati by Mark Vanfleet,
 Dr.
 John Franco, Dr.
 John Schlipf, Sean Weaver, Michal Kouril, and George Vogel.
 
\layout Section

Getting SBSat
\layout Address

SBSat is still considered research software.
 Please email franco@gauss.ececs.uc.edu for more information how to get it.
\layout Section

Compiling SBSat
\layout Standard

Considerning you obtained sbsat as tar.gz archive you will need to unpack
 it first.
 Necessary utilities are tar and gzip.
 They are present on most platforms.
 Also most platforms will let you use the following command to do so:
\layout LyX-Code

# tar -xvzf sbsat.tar.gz
\layout Standard

If this command fails please try
\layout LyX-Code

# gzip -dc sbsat.tar.gz | tar -xvf -
\layout Standard

The result should be the directory with the sources.
 Change the current directory into newly created one:
\layout LyX-Code

# cd sbsat
\layout Standard

And run configure and make:
\layout LyX-Code

# ./configure
\layout LyX-Code

# make
\layout Standard

(optional) Using the following command you can run a few included benchmarks:
\layout LyX-Code

# make check
\layout Standard

(optional) You may install the executable and associtated files onto your
 system using:
\layout LyX-Code

# make install
\layout Standard

The advantage of this step is that typically the systems have the path where
 the executable is installed (/usr/local/bin) as part of the system PATH
 variable so you will not need to specify the full path to start the executable.
\layout Section

Running SBSat
\layout Standard

SBSat executable is called ite and is located in the src directory within
 the directory containing the sources for sbsat (sbsat directory).
 Unless you installed it to your system in the previous step (make install)
 you will need to refer to it with the full path or add this path into your
 PATH variable.
 Now on I will assume that the ite was installed.
\layout Standard

The usage of SBSat is:
\layout LyX-Code

ite [options] [inputfile [outputfile]]
\layout Standard

There are two basic options required by GNU standard:
\layout LyX-Code

# ite --version
\layout Standard

This displays the current version.
\layout LyX-Code

# ite --help
\layout Standard

Shows all the command line options.
\layout Standard

If ite is started without parameters it expects the input data on standard
 input.
\layout Standard

The first parameter without dash is the input data file, the second parameter
 without is the output file.
\layout Section

Program Options
\layout Subsection

General options
\layout Standard

SBSat general options are:
\layout Standard


\emph on 
--help, -h
\emph default 
 Show all program options 
\layout Standard


\emph on 
--version
\emph default 
 Show program version 
\layout Standard


\emph on 
--create-ini
\emph default 
 Create ini file 
\layout Standard


\emph on 
--ini <string>
\emph default 
 Set the ini file [default="~/ite.ini"]
\layout Standard


\emph on 
--debug <number>
\emph default 
 debugging level (0-none, 9-max) [default=2]
\layout Standard


\emph on 
--debug-dev <string>
\emph default 
 debugging device [default="stderr"]
\layout Standard


\emph on 
--params-dump, -D
\emph default 
 dump all internal parameters before processing 
\layout Standard


\emph on 
--input-file <string>
\emph default 
 input filename [default="-"]
\layout Standard


\emph on 
--output-file <string>
\emph default 
 output filename [default="-"]
\layout Standard


\emph on 
--temp-dir <string>
\emph default 
 directory for temporary files [default="$TEMP"]
\layout Standard


\emph on 
--show-result <string>, -R <string>
\layout Standard

Show result (n=no result, r=raw, f=fancy)
\layout Standard

[default="n"]
\layout Standard


\emph on 
--verify-solution <number>
\emph default 
 Verify solution [default=1]
\layout Standard


\emph on 
--expected-result <string>
\emph default 
Report error if the result is not as specified
\layout Standard

Options are SAT, UNSAT, TRIV_SAT, TRIV_UNSAT, SOLV_S
\layout Standard

and SOLV_UNSAT
\layout Standard

[default=""]
\layout Standard


\emph on 
--ctrl-c <number> 
\layout Standard

Enable/Disable Ctrl-c handler to end preproc/brancher
\layout Standard

[default=0]
\layout Standard


\emph on 
--reports <number>
\emph default 
 Reporting style during branching (0 - standard, 1 - crtwin)
\layout Standard

[default=0]
\layout Subsection

BDD table options
\layout Standard

BDD options:
\layout Standard

--num-buckets <number> Set the number of buckets in power of 2 [default=16]
\layout Standard

--size-buckets <number> Set the size of a bucket in power of 2 [default=5]
\layout Subsection

Input options
\layout Standard

Input options:
\layout Standard

--limit-and-equ <number>
\layout Standard

The minimum # of literals to flag sp.
 function and_eq
\layout Standard

u
\layout Standard

[default=2]
\layout Standard

--limit-or-equ <number> The minimum # of literals to flag sp.
 function or_equ
\layout Standard

[default=2]
\layout Standard

--limit-or <number> The minimum # of literals to flag sp.
 function plaino
\layout Standard

r
\layout Standard

[default=8]
\layout Standard

--limit-xor <number> The minimum # of literals to flag sp.
 function plainx
\layout Standard

or
\layout Standard

[default=5]
\layout Standard

--break-xors <number> Break XORS into linear and non-linear functions
\layout Standard

[default=1]
\layout Subsection

Output options
\layout Standard

Output options:
\layout Standard

-b Start regular brancher [default]
\layout Standard

-w Start walksat brancher 
\layout Standard

-m Start WVF brancher 
\layout Standard

-n Don't start any brancher or conversion 
\layout Standard

-s Output in SMURF format 
\layout Standard

-c Output in CNF format 
\layout Standard

-p Output in tree like format 
\layout Standard

--cnf <string> Format of CNF output (3sat, qm, noqm)
\layout Standard

[default="noqm"]
\layout Standard

--tree, -tree Print tree representation 
\layout Standard

--tree-width <number>, -W <number> Set tree width [default=64]
\layout Subsection

Trace format options
\layout Standard

Trace format options:
\layout Standard

--module-dir <string> directory to find extra modules [default="./Modules"]
\layout Subsection

Preprocessing options
\layout Standard

Preprocessing options:
\layout Standard

--preprocess-sequence <string>, -P <string>
\layout Standard

The preprocessing sequence
\layout Standard

[default="(ExDc)*(ExSt)*(ExPr)*"]
\layout Standard

--All, -All Enable/Disable All Preprocessing Options (1/0) 
\layout Standard

--Cl <number>, -Cl <number> Enable/Disable Clustering (1/0) [default=1]
\layout Standard

--Co <number>, -Co <number> Enable/Disable Cofactoring (1/0) [default=1]
\layout Standard

--Pr <number>, -Pr <number> Enable/Disable Pruning (1/0) [default=1]
\layout Standard

--St <number>, -St <number>Enable/Disable Strengthening (1/0) [default=1]
\layout Standard

--In <number>, -In <number>Enable/Disable Inferences (1/0) [default=1]
\layout Standard

--Ex <number>, -Ex <number>Enable/Disable Existential Quantification (1/0)
 [default=1]
\layout Standard

--Dc <number>, -Dc <number>Enable/Disable Dependent Variable Clustering
 (1/0)
\layout Standard

[default=1]
\layout Standard

--max-preproc-time <number> set the time limit in seconds (0=no limit)[default=0
]
\layout Subsection

Brancher options
\layout Standard

Brancher options:
\layout Standard

--reverse-depend, -r Reverse dependency info on in/dependent variables 
\layout Standard

--clear-depend, -e Clear dependency information on variables 
\layout Standard

--heuristic <string>, -H <string>
\layout Standard

Choose heuristic j=Johnson, l=Chaff-like lemma h.
 i=Interactive [default="j"]
\layout Standard

--backjumping <number> Enable/Disable backjumping (1/0) [default=1]
\layout Standard

--max-cached-lemmas <number>, -L <number>
\layout Standard

set the maximum # of lemmas [default=5000]
\layout Standard

--max-solutions <number>Set the maximum number of solutions to search for.[defaul
t=1]
\layout Standard

--sbj <number> Super backjumping.
 [default=0]
\layout Standard

--max-vbles-per-smurf <number>, -S <number>
\layout Standard

set the maximum number variables per smurf [default=8]
\layout Standard

--backtracks-per-report <number>set the number of backtracks per report[default=
10000]
\layout Standard

--max-brancher-time <number>set the time limit in seconds (0=no limit)[default=0
]
\layout Standard

--max-brancher-cp <number> set the choice point limit (0=no limit) [default=0]
\layout Standard

--brancher-trace-start <number>
\layout Standard

number of backtracks to start the trace (when debug=9)[default=0]
\layout Standard

--compress-smurfs <number> Share states among smurfs [default=1]
\layout Standard

--smurfs-share-paths <number> Share paths among smurfs [default=0]
\layout Subsection

Johnson heuristic options
\layout Standard

Johnson heuristic options:
\layout Standard

--jheuristic-k <number>, -K <number> set the value of K [default=3.000000]
\layout Standard

--jheuristic-k-true <number> set the value of True state [default=0.000000]
\layout Standard

--jheuristic-k-inf <number> set the value of the inference multiplier
\layout Standard

[default=1.000000]
\layout Section


\begin_inset LatexCommand \label{sec:Input-formats}

\end_inset 

Input formats
\layout Standard

The ITE Interface is the part of the program that reads in and interprets
 the user's input file.
 This process is as follows: 
\layout Standard

1.
 Format for Input Files
\layout Subsection

BDD (ITE) input format
\layout Standard

There is a header for every input file.
 Only comments are allowed to proceed the header.
 Thus it follows that all equations, defines, etc., follow directly after
 the header.
 
\layout Standard

All equations are entered in prefix format using specific keywords and variables.
 There must be some sort of white space between all keywords and variables.
 White space is defined to be a blank, a tab, a carriage return, a comma,
 or a parentheses.
 In order to include comments in the input file, place a semi colon (";")
 prior to the comment.
 This will make the rest of the line a comment and ITE will not attempt
 to process it.
 Comments are not necessary for the program to operate, but are a convenience
 for the user.
 
\layout Subsubsection

File Header 
\layout Standard

In every input file, no equation can precede the header.
 The header conforms to the DIMACS standard which is as follows.
 
\layout LyX-Code

p bdd #InputVars #Equations 
\layout Standard

The letter 'p' at the start of a line denotes the start of the header.
 ITE requires that 'bdd' be the next three letters; these denote that the
 file is in the BDD format.
 #InputVars is a number that and tells ITE how many input variables are
 going to appear in this input file.
 #Equations is a number that tells ITE how many equations appear in this
 input file.
 Here is an example of a valid header.
 
\layout LyX-Code

p bdd 56 97 
\layout Standard

This header tells ITE that the input file is in BDD format with 56 input
 variables and 97 equations.
 
\layout Subsubsection

Keywords 
\layout Standard

Keywords are not case sensitive.
 The current keywords used, with a brief description of each are as follows:
 
\layout Itemize

INITIALBRANCH InitialBranch allows the user to specify which variables should
 be branched on first during search.
 InitialBranch is a command that should only be used when the user is sure
 he knows more information about the nature of the input file the attached
 solver will be able to derive.
 This keyword takes any number of positive integer arguments Example Use:
 InitialBranch( 1, 3, 5..18, 4, 24..39) This will mark variables 1, 3, 5..18 (inclusiv
e), 4, 24..39 (inclusive) to be branched on first.
 *Note that this keyword is the only keyword which requires parenthesis
 around it's argument list* 
\layout Itemize

VAR is the Base keyword to all equations.
 It takes one(1) argument, which must be an integer.
 VAR creates a BDD for the variable following it.
 This BDD will have a true branch and a false branch.
 
\newline 
The keyword VAR has been made obsolete.
 It is no longer necessary to place VAR in front of every variable.
 It is now assumed that all integers are variables unless preceded by a
 '$'.
 All integers preceded by a '$' refer to equations instead of variables.
\layout Itemize

NOT The NOT function takes one(1) argument and forms a BDD which represents
 the negation of that argument.
 When negating a single variable, a negative sign ("-") can be placed directly
 in front of the variable as a shortcut (See Shortcuts)
\layout Itemize

ITE The ITE function takes three(3) arguments and forms a BDD which expresses
 the If-Then-Else relation of the three(3) arguments.
 The function builds a BDD so that if the first parameter evaluates to true,
 then the second parameter must be true, else the third parameter must be
 true.
 Every BDD possible can be expressed using the ITE function.
 
\layout LyX-Code

Example: ITE( ITE( 3, $5, -5), 4, 7) 
\layout LyX-Code

(Assume $5 has been previously defined.
 *Note that the use of parenthesis and commas here is allowed but not required*)
 
\layout Itemize

AND takes two(2) arguments and creates a BDD which expresses the logical
 AND of the two(2) arguments.
 Example: AND 3 4 
\layout Itemize

AND# AND followed directly by a positive integer is a shortcut designed
 to allow the user to send more than two(2) arguments to the AND function.
 Any number of arguments is supported here.
 Example 1: AND4(1, 2, 3, 4) Example 2: AND5(-1, AND3(2, 3, $4), 5, $6,
 7) Assume $4 and $6 have been previously defined.
 *Note that the use of white space here is allowed but not required* 
\layout Itemize

NAND takes two(2) arguments and creates a BDD which expresses NOT of the
 logical AND of the two(2) arguments.
 
\layout Itemize

NAND# NAND followed directly by a positive integer is a shortcut designed
 to allow the user to send more than two(2) arguments to the NAND function.
 Any number of arguments is supported here.
 
\layout Itemize

OR OR takes two(2) arguments and creates a BDD which expresses the logical
 OR of the two(2) arguments.
 
\layout Itemize

OR# OR followed directly by a positive integer is a shortcut designed to
 allow the user to send more than two(2) arguments to the OR function.
 Any number of arguments is supported here.
 
\layout Itemize

NOR NOR takes two(2) arguments and creates a BDD which expresses the NOT
 of the logical OR of the two(2) arguments.
 
\layout Itemize

NOR# NOR followed directly by a positive integer is a shortcut designed
 to allow the user to send more than two(2) arguments to the NOR function.
 Any number of arguments is supported here.
 
\layout Itemize

EQU EQU takes two(2) arguments and creates a BDD which expresses that these
 two(2) arguments are equal to each other.
 
\layout Itemize

EQU# EQU followed directly by a positive integer is a shortcut designed
 to allow the user to send more than two(2) arguments to the EQU function.
 Any number of arguments is supported here.
 
\layout Itemize

XOR XOR takes two(2) arguments and creates a BDD which expresses that these
 two(2) arguments are opposite of each other.
 
\layout Itemize

XOR# XOR followed directly by a positive integer is a shortcut designed
 to allow the user to send more than two(2) arguments to the XOR function.
 Any number of arguments is supported here.
 
\layout Itemize

IMP IMP takes two(2) arguments and creates a BDD which expresses the logical
 implication of the two(2) arguments.
 *Take note that IMP does not support multiple arguments as many of the
 other keywords do, this is because the implication operator has strict
 variable ordering dependence.* 
\layout Itemize

NIMP NIMP takes two(2) arguments and creates a BDD which expresses the NOT
 of the logical implication of the two(2) arguments.
 *Take note that NIMP does not support multiple arguments as many of the
 other keywords do, this is because the implication operator has strict
 variable ordering dependence.* 
\layout Itemize

GCF The GCF keyword takes two(2) arguments.
 This function finds all solutions of both parameters and then creates a
 BDD which represents the intersection of these solutions.
 GCF stands for Generalized Co-Factoring.
 
\layout Itemize

STRENGTHEN STRENGTHEN takes two(2) arguments, e1 and e2.
 This function uses the information in e2 to strengthen e1.
 (See Strengthening, page ??) 
\layout Itemize

PRUNE PRUNE takes two(2) arguments, e1 and e2.
 This function prunes all branches found in e2 away from e1.
 (See Branch Pruning, page ??) 
\layout Itemize

EXIST EXIST takes two(2) arguments, the first argument can be an equation
 or a variable (e1), the second argument must be a variable (v1).
 This function searches for and finds everyplace in e1 where v1 occurs.
 Every time v1 is found it is replaced by the logical OR of it's true branch
 and it's false branch.
 This function effectively removes v1 from e1.
 (See Existential Quantification, page ??) 
\layout Itemize

UNIVERSE UNIVERSE takes two(2) arguments, the first argument can be an equation
 or a variable (e1), the second argument must be a variable (v1).
 This function searches for and finds everyplace in e1 where v1 occurs.
 Every time v1 is found it is replaced by the logical AND of it's true branch
 and it's false branch.
 This function effectively removes v1 from e1.
 
\layout Itemize

PRINT_TREE This function takes one(1) argument.
 The argument is printed to standard out in a nice, easily readable tree
 form.
 The argument is printed from the top down.
 To the branch to the left is the true branch, the branch to the right is
 the false branch.
 
\layout LyX-Code

Example: PRINT_TREE( OR3(4, 5, -6) ) 
\layout LyX-Code

Prints to standard output:
\layout LyX-Code

--------------------------------------------------- 
\layout LyX-Code

4 
\layout LyX-Code

T 5 
\layout LyX-Code

T 6 
\layout LyX-Code

F T 
\layout LyX-Code

--------------------------------------------------- 
\layout Itemize

PPRINT_TREE This function takes one(1) argument.
 The argument is printed to standard out in a different form than PRINT_TREE.
 If the true and false branches are T and F then they are printed on the
 same line, otherwise, the true and false branches are indented from the
 top variable.
 The true branch is printed first and is followed by the false branch.
 
\layout LyX-Code

Example: PPRINT_TREE( OR3(4, 5, -6) ) 
\layout LyX-Code

Prints to standard output:
\layout LyX-Code

-------------------------------------------------------
\layout LyX-Code

ite 4 T ite 5 T ite 6 F T
\layout LyX-Code

------------------------------------------------------- 
\layout Itemize

ADD_STATE This function takes two(2) arguments.
 The first argument (e1) must be an equation and the second argument must
 be a positive integer (i1).
 ADD_STATE creates a new BDD with structure identical e1 but with each variable
 incremented by i1.
 
\layout LyX-Code

Example: ADD_STATE( AND(3, 4), 5 ) This will create the BDD - AND(8, 9)
 
\layout Subsubsection

Variable Names 
\layout Subsubsection

Reusing Functions
\layout Subsubsection

Defines 
\layout Subsubsection

Short Cuts 
\layout Subsubsection

Example Input 
\layout LyX-Code

p bdd 18 13 ; 18 vars, 13 functions 
\layout LyX-Code

#define fun 1 2 3 4 
\layout LyX-Code

# ite 1 and 2 3 or 3 4 ; parms must be consecutive integers from 1 
\layout LyX-Code

#define g 1 2 3 
\layout LyX-Code

# ite fun 1 2 3 -2 T 3 
\layout LyX-Code

InitialBranch (2, 4..12, 15, 16, 18, 1, 3) ; These variables will be branched
 on first 
\layout LyX-Code

ite 4 5 6 ; eqn $1 
\layout LyX-Code

*or $1 3 ; eqn $2, smurf 1 
\layout LyX-Code

*or 5 -6 ; eqn $3, smurf 2 
\layout LyX-Code

*and $1 -4 ; eqn $4, smurf 3 
\layout LyX-Code

*imp $1 $4 ; eqn $5, smurf 4 
\layout LyX-Code

#define imp 1 2 3 
\layout LyX-Code

# or3(1, 2, 3); Notice the 'imp' operator was overloaded to be the OR of
 3 variables.
 
\layout LyX-Code

*imp(3 4 5) ; eqn $6, smurf 5 ; this is a really bad idea, it probably shouldn't
 be allowed 
\layout LyX-Code

print_tree $5; no equation created, no smurf created pprint_tree $5 ; no
 equation created, no smurf created 
\layout LyX-Code

ite 2 ; eqn $7 ite 3 4 5 ; plus comments are ignored, even in the middle
 of a function 
\layout LyX-Code

ite 4 5 F 
\layout LyX-Code

*fun 4 -5 2 3 ; eqn $8, smurf 5 
\layout LyX-Code

*fun g -5 4 $6 2 3 4 ; eqn $9, smurf 6 
\layout LyX-Code

*equ(xor3(2, and(-3, 4), nand(7, 5), ite(15, or(4, -7), nor(4, -7)))) ;
 eqn $10, smurf 7 
\layout LyX-Code

*add_state($10, 1) ; eqn $11, smurf 7 ; add_state creates a BDD which is
 identical to the first argument but ;with all it's variables incremented
 by the second argument.
 *add_state($10, 2) ; eqn $12, smurf 8 
\layout LyX-Code

*add_state($10, 3) ; eqn $13, smurf 9
\layout LyX-Code

\layout Subsection

CNF format
\layout Subsection

TRACE format
\layout Subsection

SMURF format
\layout Section

Preprocessing
\layout Standard

III.
 The BDD Tool 
\layout Standard

Data is presented the ITE program via an input file.
 In this file BDD variables and BDDs are expressed using all Boolean functions,
 e.g., NOT, AND, NAND, OR, NOR, EQU, XOR, IMPLIES, etc.
 (See page ?? for a full list of commands and a description of each).
 Every BDD expressed may be reused when creating other BDD expressions.
 Input from this file continues until the specified number of user inputs
 has been processed (See page ??).
 
\layout Standard

The ITE program processes the input given to the program, but the main tool
 exercised is the BDD Tool.
 It completes all of the manipulations and calculations necessary to build
 the BDD structure.
 The BDD Tool comes standard with many powerful BDD functions (See page
 ??).
 These functions give the user total control over their problem data.
 
\layout Section

Solver
\layout Subsection

Brancher
\layout Subsection

BDDWalkSat
\layout Subsection

WVF Brancher
\layout Section

Solver heuristics
\layout Subsection

Johnson heuristic
\layout Subsection

Chaff like lemma heuristic
\layout Section

Output formats
\layout Standard

For format description please see Section\SpecialChar ~

\begin_inset LatexCommand \ref{sec:Input-formats}

\end_inset 

.
\layout Section

Examples on how to use SBSat
\layout Section

Reporting problems
\layout Address

Report bugs to <mkouril@ececs.uc.edu> or <franco@gauss.ececs.uc.edu>.
\the_end
